set nocompatible
filetype off

set runtimepath+=~/.vim/bundle/vundle/
call vundle#rc()

" Bundles {{{1
Bundle 'gmarik/vundle'

Bundle 'kien/ctrlp.vim'
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-commentary'
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-unimpaired'
Bundle 'tpope/vim-vinegar'
Bundle 'justinmk/vim-sneak'
Bundle 'scrooloose/syntastic'
Bundle 'PeterRincker/vim-argumentative'
Bundle 'godlygeek/tabular'
Bundle 'ervandew/supertab'

Bundle 'kana/vim-textobj-user'
Bundle 'kana/vim-textobj-indent'
Bundle 'kana/vim-textobj-diff'
Bundle 'kana/vim-operator-user'
Bundle 'kana/vim-operator-replace'
Bundle 'nelstrom/vim-textobj-rubyblock'
Bundle 'Julian/vim-textobj-variable-segment'

Bundle 'tpope/vim-git'
Bundle 'aliva/vim-fish'
Bundle 'othree/html5.vim'
Bundle 'pangloss/vim-javascript'
Bundle 'kchmck/vim-coffee-script'
Bundle 'vim-scripts/VimClojure'
Bundle 'derekwyatt/vim-scala'
Bundle 'vim-ruby/vim-ruby'
Bundle 'hynek/vim-python-pep8-indent'

Bundle 'sjl/badwolf'
Bundle 'sickill/vim-monokai'
" }}}1

" Options {{{1
filetype plugin indent on

set shell=/bin/bash

set cpoptions+=J

set novisualbell t_vb=
set title
set t_Co=256
set ttyfast
set lazyredraw        " Do not redraw buffer then executing macros etc.
set mousehide

set termencoding=utf-8
set fileencodings=utf-8,windows-1251,iso-8859-15,koi8-r
set encoding=utf8

set hidden
set virtualedit=all
set backspace=indent,eol,start
set nojoinspaces
set formatoptions-=o  " Do not continue comments when pressing o/O
set shellslash
set autoread
set autowrite

set scrolljump=1
set scrolloff=7
set sidescrolloff=10
set sidescroll=10

set incsearch
set hlsearch
set wrapscan
set ignorecase
set smartcase
set noinfercase
set gdefault

set autoindent
set smartindent
set shiftwidth=4
set softtabstop=4
set tabstop=4
set expandtab

set nowrap
set textwidth=79
set showmatch
set list
set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
if !has('win32') && (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8')
    let &listchars = "tab:\u21e5 ,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u00b7"
endif

if exists('&colorcolumn')
    set colorcolumn=80
endif

set foldmethod=indent
set foldlevel=20

set wildmenu
set wildcharm=<TAB>
set wildmode=list:longest

set wildignore+=.git,.hg,_darcs,.svn
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest
set wildignore+=*.pyc,*.pyo
set wildignore+=*.hi
set wildignore+=*.luac
set wildignore+=*.aux,*.out,*.toc
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.spl
set wildignore+=*.sw?
set wildignore+=*.DS_Store?
set wildignore+=*.mo
set wildignore+=*.class
set wildignore+=node_modules
set wildignore+=.env

set nobackup
set directory=$HOME/.vim/tmp
set viminfo='128,/32,:32,<64,@32,s10,h,n$HOME/.vim/viminfo
set sessionoptions=blank,buffers,curdir,slash,tabpages,unix
set cryptmethod=blowfish

set diffopt+=iwhite

set splitright
set splitbelow

set fillchars=""  " Get rid of the silly characters in window separators
set showcmd       " Show partial command (or visual selection size) in cmd line
set cmdheight=2
set laststatus=2

set statusline=%*\ %f\ %<
set statusline+=%1*%m%*
set statusline+=%1*%r%*
set statusline+=%=
set statusline+=\ %{&fileformat}\ %{&fileencoding}
set statusline+=\ %{strlen(&filetype)>0?&filetype:'no-ft'}
set statusline+=\ %04b/0x%03B
set statusline+=\ %03vx%3*%03l%*/%03L
set statusline+=%*

set numberwidth=3
set nonumber
if exists('&relativenumber')
    set norelativenumber
endif

if has('gui_running') " {{{2
    set mouse=a
    set mousemodel=popup

    set guioptions-=T  " No toolbar
    set guioptions-=l  " No scrollbars
    set guioptions-=r
    set guioptions-=L
    set guioptions-=R
    set guioptions-=m  " No menu

    set guicursor=n-v-c:block-Cursor-blinkon0
    set guicursor+=ve:ver35-Cursor
    set guicursor+=o:hor50-Cursor
    set guicursor+=i-ci:ver25-Cursor
    set guicursor+=r-cr:hor20-Cursor
    set guicursor+=sm:block-Cursor-blinkwait175-blinkoff150-blinkon17

    set guifont=Ubuntu\ Mono
endif " }}}2

syntax on
set synmaxcol=512
" }}}1

" Mappings {{{1
let mapleader = ","
let maplocalleader = "\\"
set pastetoggle=<F12>

nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

nnoremap / /\v

nnoremap Y y$

nnoremap H <C-w><C-h>
nnoremap L <C-w><C-l>
nnoremap K <C-w><C-w>

" Center screen on search match
nnoremap n nzzzv
nnoremap N Nzzzv

" Select just pasted text
nnoremap <leader>v V`]

" Paste in visual mode without losing register content
xnoremap <expr> p v:register=='"'?'pgvy':'p'

" Allow command line editing like emacs
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-B> <Left>
cnoremap <C-F> <Right>
cnoremap <C-N> <Down>
cnoremap <C-P> <Up>

" Write as sudo
cnoremap w!! w !sudo tee % >/dev/null

" Toggle wrap
nnoremap <leader>iw :set invwrap<CR>:set wrap?<CR>
" Toggle line numbers
nnoremap <leader>in :set invnumber<CR>:set number?<CR>
" Toggle spell checking
nnoremap <leader>is :set invspell<CR>:set spell?<CR>

" Disable search highlight
nnoremap <silent> <C-L> :nohlsearch<CR><C-L>
" Highlight all instances of the current word under the cursor
nnoremap <silent> <leader>hh :setl hls<CR>:let @/="\\<<C-r><C-w>\\>"<CR>

nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>rv :source $MYVIMRC<cr>

" Plugins
let g:ctrlp_map = '<leader>t'
let g:sneak#streak = 1
map gr <Plug>(operator-replace)

nnoremap <C-p> :CtrlPMRU<CR>

nnoremap ys<space> ysl<space><space>

nnoremap <silent> <leader>gs :Gstatus<CR>
nnoremap <silent> <leader>gl :Glog<CR>
nnoremap <silent> <leader>gc :Gcommit<CR>
nnoremap <silent> <leader>gd :Gdiff<CR>
nnoremap <silent> <leader>gw :Gwrite<CR>
nnoremap <silent> <leader>gr :Gread<CR>
nnoremap <silent> <leader>ge :Gedit<CR>
nnoremap <silent> <leader>gg :Ggrep <C-r><C-w><CR>

nnoremap <F6> :GundoToggle<CR>
nnoremap <F7> :SyntasticCheck<CR>

" }}}1

" Plugins {{{1
runtime macros/matchit.vim

" Fugitive
if has("autocmd")
    augroup fugutiveAU
        autocmd!
        autocmd BufReadPost fugitive://* set bufhidden=delete
        autocmd User fugitive
          \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
          \     nnoremap <buffer> .. :edit %:h<CR> |
          \ endif
    augroup END
endif

let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
if has('win32')
    let g:ctrlp_cache_dir = $TEMP.'/ctrlp'
endif

let g:syntastic_mode_map = { 'mode': 'active',
                           \ 'active_filetypes': [],
                           \ 'passive_filetypes': ['java'] }
" }}}1

" Autocommands {{{1
if has("autocmd")
    augroup FTOptions " {{{2
        autocmd!
        autocmd FileType vim setlocal foldmethod=marker

        autocmd FileType sh setlocal foldmethod=marker
        autocmd FileType zsh setlocal foldmethod=marker

        autocmd FileType mail setlocal wrap
        autocmd FileType gitcommit setlocal spell textwidth=72

        autocmd FileType python setlocal sw=4 sts=4 ts=4 et nosmartindent
        autocmd FileType ruby,eruby setlocal sw=2 sts=2 ts=2 et
        autocmd FileType lisp setlocal commentstring=;;%s

        autocmd FileType html,htmldjango,liquid setlocal sw=2 sts=2 ts=2 et tw=0
        autocmd FileType yaml setlocal sw=2 sts=2 ts=2 et
        autocmd FileType coffee,javascript setlocal sw=2 sts=2 ts=2 et

        autocmd FileType css,less,scss setlocal sw=2 sts=2 ts=2 et tw=0
    augroup END " }}}2

    augroup Misc " {{{2
        autocmd!
        autocmd FocusLost * :wa
        autocmd VimResized * exe "normal! \<c-w>="
    augroup END " }}}2

    augroup Whitespace " {{{2
        autocmd!
        " Highlight EOL whitespace, http://vim.wikia.com/wiki/Highlight_unwanted_spaces
        autocmd ColorScheme * highlight ExtraWhitespace ctermbg=darkred guibg=#382424
        autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
        " the above flashes annoyingly while typing, be calmer in insert mode
        autocmd InsertLeave * match ExtraWhitespace /\s\+$/
        autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
    augroup END " }}}2
end
" }}}1

" Commands {{{1

" Visual star {{{
function! s:VSetSearch()
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = temp
endfunction

vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR><c-o>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR><c-o>
" }}}

" Next and Last {{{

" Motion for "next/last object". "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type in the current line, last acts
" on the previous object of the given type in the current line.
"
" Currently only works for (, [, {, b, r, B, ', and ".
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din' -> delete in next single quotes foo = bar('spam')
" C
" foo = bar('')
" C
"
" canb -> change around next parens foo = bar('spam')
" C
" foo = bar
" C
"
" vil" -> select inside last double quotes print "hello ", name
" C
" print "hello ", name
" VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>

function! s:NextTextObject(motion, dir)
  let c = nr2char(getchar())

  if c ==# "b"
      let c = "("
  elseif c ==# "B"
      let c = "{"
  elseif c ==# "r"
      let c = "["
  endif

  exe "normal! ".a:dir.c."v".a:motion.c
endfunction
" }}}

" Fix whitespace {{{
highlight ExtraWhitespace ctermbg=darkred guibg=#382424

function! s:FixWhitespace(line1,line2)
    let l:save_cursor = getpos(".")
    silent! execute ':' . a:line1 . ',' . a:line2 . 's/\s\+$//'
    call setpos('.', l:save_cursor)
endfunction

" Run :FixWhitespace to remove end of line white space.
command! -range=% FixWhitespace call <SID>FixWhitespace(<line1>,<line2>)
" }}}

" }}}

" Abbreviations {{{1
function! EatChar(pat)
    let c = nr2char(getchar(0))
    return (c =~ a:pat) ? '' : c
endfunction

function! MakeSpacelessIabbrev(from, to)
    execute "iabbrev <silent> ".a:from." ".a:to."<C-R>=EatChar('\\s')<CR>"
endfunction

call MakeSpacelessIabbrev('***', '*args, **kwargs')
call MakeSpacelessIabbrev('pdb', 'import pdb; pdb.set_trace()')

iab wekk week
iab Wekk Week
iab chage change
iab Chage Change
iab reutrn return
iab reutn return
iab reurn return
iab labmda lambda
iab consoel console
" }}}

" Statusline {{{
hi User3 guifg=#4e4e4e guibg=#ffffff gui=bold ctermfg=239 ctermbg=255 cterm=bold

let g:last_mode = ''
function! MylineMode()
  let l:mode = mode()

  if l:mode !=# g:last_mode
    let g:last_mode = l:mode

    hi User2 guifg=#005f00 guibg=#dfff00 gui=bold ctermfg=22 ctermbg=190 cterm=bold

    if l:mode ==# 'n'
    elseif l:mode ==# "i"
      hi User2 guifg=#005fff guibg=#ffffff ctermfg=27 ctermbg=255
    elseif l:mode ==# "R"
      hi User2 guifg=#ffffff guibg=#df0000 ctermfg=255 ctermbg=160
    elseif l:mode ==? "v" || l:mode ==# ""
      hi User2 guifg=#4e4e4e guibg=#ffaf00 ctermfg=239 ctermbg=214
    endif
  endif

  if     l:mode ==# "n"  | return "  NORMAL "
  elseif l:mode ==# "i"  | return "  INSERT "
  elseif l:mode ==# "v"  | return "  VISUAL "
  elseif l:mode ==# "V"  | return "  V·LINE "
  elseif l:mode ==# "" | return "  V·BLOK "
  elseif l:mode ==# "R"  | return "  REPLACE "
  else                   | return l:mode
  endif
endfunction

function! MylineUpdate(active)
    if !a:active
        let sl = '%* %f %< %1*%m%*'
    else
        let sl = '%2*%{MylineMode()}%3*'
        let sl.= '%{strlen(fugitive#statusline()) > 0 ? " " : ""}'
        let sl.= '%{matchstr(fugitive#statusline(), "(\\zs.*\\ze)")}'
        let sl.= '%{strlen(fugitive#statusline()) > 0 ? " " : ""}'
        let sl.= '%1*%m%*'
        let sl.= '%1*%r%*'
        let sl.= '%<%* %f'
        let sl.= '%#WarningMsg#%{SyntasticStatuslineFlag()}%*'
        let sl.= '%=%*'
        let sl.= ' %{&fileformat} %{&fileencoding}'
        let sl.= ' %{strlen(&filetype)>0?&filetype:"no-ft"}'
        let sl.= ' %04b/0x%03B'
        let sl.= ' %03vx%3*%03l%*/%03L'
        let sl.= '%*'
    endif
    if &ft == 'nerdtree' | let sl = '%* NERDTree'
    elseif &ft == 'gitcommit' | let sl = '%* Git'
    elseif &ft == 'netrw' | let sl = '%* %f'
    endif
    call setwinvar(winnr(), '&statusline', sl)
endfunction

augroup statusline
    au!
    autocmd WinLeave * call MylineUpdate(0)
    autocmd WinEnter,BufWinEnter * call MylineUpdate(1)
augroup END
" }}}

if filereadable($HOME."/.vim/local/vimrc")
    set runtimepath+=$HOME/.vim/local/
    source $HOME/.vim/local/vimrc
endif
